import { z } from "zod";

export const RECURRING_URL = "https://secure.nmi.com/api/transact.php";

export const AddRecurringPlanSchema = z.object({
  recurring: z.literal("add_plan").describe(`Add a new recurring plan`),
  plan_payments: z
    .number()
    .int()
    .default(0)
    .describe(
      `The number of payments before the recurring plan is complete. 0 for infinite.`
    ),
  plan_amount: z
    .number()
    .default(0.0)
    .describe(`The amount to charge for each payment (x.xx format)`),
  plan_name: z.string().describe(`The name of the recurring plan`),
  plan_id: z.string().describe(`The ID of the recurring plan`),
  day_frequency: z
    .number()
    .int()
    .default(0)
    .describe(
      `The frequency, in days, to charge the customer. Cannot be set with 'month_frequency' or 'day_of_month'`
    ),
  month_frequency: z
    .number()
    .int()
    .default(0)
    .describe(
      `The frequency, in months, to charge the customer. Cannot be set with 'day_frequency', must be set with 'day_of_month'`
    ),
  day_of_month: z
    .number()
    .int()
    .default(0)
    .describe(
      `The day of the month to charge the customer. Cannot be set with 'day_frequency' or 'month_frequency'`
    ),
});

export type AddRecurringPlan = z.infer<typeof AddRecurringPlanSchema>;

export const EditRecurringPlanSchema = z.object({
  recurring: z.literal("edit_plan").describe(`Edit an existing recurring plan`),
  current_plan_id: z.string().describe(`The ID of the recurring plan to edit`),
  plan_payments: z
    .number()
    .int()
    .optional()
    .describe(
      `The number of payments before the recurring plan is complete. 0 for infinite.`
    ),
  plan_amount: z
    .number()
    .optional()
    .describe(`The amount to charge for each payment (x.xx format)`),
  plan_name: z.string().optional().describe(`The name of the recurring plan`),
  plan_id: z.string().optional().describe(`The ID of the recurring plan`),
  day_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in days, to charge the customer. Cannot be set with 'month_frequency' or 'day_of_month'`
    ),
  month_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in months, to charge the customer. Cannot be set with 'day_frequency', must be set with 'day_of_month'`
    ),
  day_of_month: z
    .number()
    .int()
    .optional()
    .describe(
      `The day of the month to charge the customer. Cannot be set with 'day_frequency' or 'month_frequency'`
    ),
});

export type EditRecurringPlan = z.infer<typeof EditRecurringPlanSchema>;

export const AddSubscriptionToExistingPlanSchema = z.object({
  recurring: z
    .literal("add_subscription")
    .describe(`Add a new subscription to an existing recurring plan`),
  plan_id: z
    .string()
    .describe(`The ID of the recurring plan to add the subscription to`),
  start_date: z
    .string()
    .optional()
    .describe(`The date to start the subscription. Format: YYYYMMDD`),
  payment_token: z
    .string()
    .optional()
    .describe(
      `The payment token of the customer's card or check information. This will e generated by Collect.js and usable only once.`
    ),
  googlepay_payment_data: z
    .string()
    .optional()
    .describe(
      `The encrypted token creted when integrated directly with the Google Pay SDK`
    ),
  ccnumber: z
    .string()
    .optional()
    .describe(`The credit card number of the customer`),
  ccexp: z
    .string()
    .optional()
    .describe(`The expiration date of the credit card. Format: MMYY`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .describe(`The payment method to use for the subscription`),
  checkname: z
    .string()
    .optional()
    .describe(`The name on the customer's ACH account`),
  checkaccount: z
    .string()
    .optional()
    .describe(`The account number of the customer's ACH account`),
  checkaba: z
    .string()
    .optional()
    .describe(`The ABA routing number of the customer's ACH account`),
  account_type: z
    .literal("checking")
    .or(z.literal("savings"))
    .optional()
    .describe(`The type of account for the customer's ACH account`),
  currency: z
    .string()
    .optional()
    .default("USD")
    .describe(`The currency of the subscription. Defaults to USD`),
  account_holder_type: z
    .literal("personal")
    .or(z.literal("business"))
    .optional()
    .describe(`The type of account holder for the customer's ACH account`),
  sec_code: z
    .literal("PPD")
    .or(z.literal("WEB"))
    .or(z.literal("TEL"))
    .or(z.literal("CCD"))
    .optional()
    .describe(`The SEC code for the customer's ACH account`),
  first_name: z.string().optional().describe(`The first name of the customer`),
  last_name: z.string().optional().describe(`The last name of the customer`),
  address1: z.string().optional().describe(`The address of the customer`),
  address2: z.string().optional().describe(`The address of the customer`),
  city: z.string().optional().describe(`The city of the customer`),
  state: z.string().optional().describe(`The state of the customer`),
  zip: z.string().optional().describe(`The zip code of the customer`),
  country: z.string().optional().describe(`The country of the customer`),
  phone: z.string().optional().describe(`The phone number of the customer`),
  email: z
    .string()
    .email()
    .optional()
    .describe(`The email address of the customer`),
  company: z.string().optional().describe(`The company name of the customer`),
  fax: z.string().optional().describe(`The fax number of the customer`),
  orderid: z.string().optional().describe(`The order ID of the order`),
  order_description: z
    .string()
    .optional()
    .describe(`A description of the order`),
  custom_fields: z
    .record(z.string())
    .optional()
    .describe(`Custom fields to add to the subscription`),
  ponumber: z
    .string()
    .optional()
    .describe(`The purchase order number of the order`),
  processor_id: z
    .string()
    .optional()
    .describe(
      `If using Multiple MIDs, route to this processor (processor_id is obtained under Settings ? Transaction Routing in the Control Panel). If allowing multiple payment types, one processor_id can be selected per payment type by submitting comma-separated values.`
    ),
  customer_receipt: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Send the customer a receipt for the subscription. Defaults to true`
    ),
  source_transaction_id: z
    .string()
    .optional()
    .describe(
      `Specifies a payment gateway transaction id in order to associate payment information with a Subscription record`
    ),
  acu_enabled: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Enable Automated Collection Updater (ACU) for this subscription. Defaults to false`
    ),
});

export type AddSubscriptionToExistingPlan = z.infer<
  typeof AddSubscriptionToExistingPlanSchema
>;

export const AddSubscriptionToExistingPlanRequestSchema =
  AddSubscriptionToExistingPlanSchema.transform((data) => {
    // Then we need to take the custom fields and turn it into merchant_defined_field_1, merchant_defined_field_2, etc.
    const customFields = data.custom_fields || {};
    const transformedCustomFields = Object.keys(customFields).reduce(
      (acc, key, index) => {
        const newKey = `merchant_defined_field_${index + 1}`;
        return { ...acc, [newKey]: customFields[key] };
      },
      {}
    );
    // Then we return the correct object for parsing for the request
    return { ...data, ...transformedCustomFields };
  });

export type AddSubscriptionToExistingPlanRequest = z.infer<
  typeof AddSubscriptionToExistingPlanRequestSchema
>;

export const AddCustomSubscriptionSchema = z.object({
  recurring: z
    .literal("add_subscription")
    .describe(`Add a new subscription to a non-existing recurring plan`),
  plan_payments: z
    .number()
    .int()
    .default(0)
    .describe(
      `The number of payments before the recurring plan is complete. 0 for infinite.`
    ),
  plan_amount: z
    .number()
    .default(0.0)
    .describe(`The amount to charge for each payment (x.xx format)`),
  day_frequency: z
    .number()
    .int()
    .default(0)
    .describe(
      `The frequency, in days, to charge the customer. Cannot be set with 'month_frequency' or 'day_of_month'`
    ),
  month_frequency: z
    .number()
    .int()
    .default(0)
    .describe(
      `The frequency, in months, to charge the customer. Cannot be set with 'day_frequency', must be set with 'day_of_month'`
    ),
  day_of_month: z
    .number()
    .int()
    .default(0)
    .describe(
      `The day of the month to charge the customer. Cannot be set with 'day_frequency' or 'month_frequency'`
    ),
  start_date: z
    .string()
    .optional()
    .describe(`The date to start the subscription. Format: YYYYMMDD`),
  payment_token: z
    .string()
    .optional()
    .describe(
      `The payment token of the customer's card or check information. This will e generated by Collect.js and usable only once.`
    ),
  googlepay_payment_data: z
    .string()
    .optional()
    .describe(
      `The encrypted token creted when integrated directly with the Google Pay SDK`
    ),
  ccnumber: z
    .string()
    .optional()
    .describe(`The credit card number of the customer`),
  ccexp: z
    .string()
    .optional()
    .describe(`The expiration date of the credit card. Format: MMYY`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .default("creditcard")
    .describe(`The payment method to use for the subscription`),
  checkname: z
    .string()
    .optional()
    .describe(`The name on the customer's ACH account`),
  checkaccount: z
    .string()
    .optional()
    .describe(`The account number of the customer's ACH account`),
  checkaba: z
    .string()
    .optional()
    .describe(`The ABA routing number of the customer's ACH account`),
  account_type: z
    .literal("checking")
    .or(z.literal("savings"))
    .optional()
    .describe(`The type of account for the customer's ACH account`),
  account_holder_type: z
    .literal("personal")
    .or(z.literal("business"))
    .optional()
    .describe(`The type of account holder for the customer's ACH account`),
  sec_code: z
    .literal("PPD")
    .or(z.literal("WEB"))
    .or(z.literal("TEL"))
    .or(z.literal("CCD"))
    .optional()
    .describe(`The SEC code for the customer's ACH account`),
  first_name: z.string().optional().describe(`The first name of the customer`),
  last_name: z.string().optional().describe(`The last name of the customer`),
  address1: z.string().optional().describe(`The address of the customer`),
  address2: z.string().optional().describe(`The address of the customer`),
  city: z.string().optional().describe(`The city of the customer`),
  state: z.string().optional().describe(`The state of the customer`),
  zip: z.string().optional().describe(`The zip code of the customer`),
  country: z.string().optional().describe(`The country of the customer`),
  phone: z.string().optional().describe(`The phone number of the customer`),
  email: z
    .string()
    .email()
    .optional()
    .describe(`The email address of the customer`),
  company: z.string().optional().describe(`The company name of the customer`),
  fax: z.string().optional().describe(`The fax number of the customer`),
  orderid: z.string().optional().describe(`The order ID of the order`),
  order_description: z
    .string()
    .optional()
    .describe(`A description of the order`),
  custom_fields: z
    .record(z.string())
    .optional()
    .describe(`Custom fields to add to the subscription`),
  ponumber: z
    .string()
    .optional()
    .describe(`The purchase order number of the order`),
  processor_id: z
    .string()
    .optional()
    .describe(
      `If using Multiple MIDs, route to this processor (processor_id is obtained under Settings ? Transaction Routing in the Control Panel). If allowing multiple payment types, one processor_id can be selected per payment type by submitting comma-separated values.`
    ),
  customer_receipt: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Send the customer a receipt for the subscription. Defaults to true`
    ),
  source_transaction_id: z
    .string()
    .optional()
    .describe(
      `Specifies a payment gateway transaction id in order to associate payment information with a Subscription record`
    ),
  acu_enabled: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Enable Automated Collection Updater (ACU) for this subscription. Defaults to false`
    ),
  paused_subscription: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(`Pause the subscription after creation. Defaults to false`),
});

export type AddCustomSubscription = z.infer<typeof AddCustomSubscriptionSchema>;

export const AddCustomSubscriptionRequestSchema =
  AddCustomSubscriptionSchema.transform((data) => {
    // Then we need to take the custom fields and turn it into merchant_defined_field_1, merchant_defined_field_2, etc.
    const customFields = data.custom_fields || {};
    const transformedCustomFields = Object.keys(customFields).reduce(
      (acc, key, index) => {
        const newKey = `merchant_defined_field_${index + 1}`;
        return { ...acc, [newKey]: customFields[key] };
      },
      {}
    );
    // Then we return the correct object for parsing for the request
    return { ...data, ...transformedCustomFields };
  });

export type AddCustomSubscriptionRequest = z.infer<
  typeof AddCustomSubscriptionRequestSchema
>;

export const UpdateCustomSubscriptionRequestSchema = z.object({
  recurring: z
    .literal("update_subscription")
    .describe(`Update an existing subscription`),
  subscription_id: z.string().describe(`The ID of the subscription to update`),
  plan_payments: z
    .number()
    .int()
    .optional()
    .describe(
      `The number of payments before the recurring plan is complete. 0 for infinite.`
    ),
  plan_amount: z
    .number()
    .optional()
    .describe(`The amount to charge for each payment (x.xx format)`),
  day_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in days, to charge the customer. Cannot be set with 'month_frequency' or 'day_of_month'`
    ),
  month_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in months, to charge the customer. Cannot be set with 'day_frequency', must be set with 'day_of_month'`
    ),
  day_of_month: z
    .number()
    .int()
    .optional()
    .describe(
      `The day of the month to charge the customer. Cannot be set with 'day_frequency' or 'month_frequency'`
    ),
});

export type UpdateCustomSubscriptionRequest = z.infer<
  typeof UpdateCustomSubscriptionRequestSchema
>;

export const UpdateSubscriptionSchema = z.object({
  recurring: z
    .literal("update_subscription")
    .describe(`Update an existing subscription`),
  subscription_id: z.string().describe(`The ID of the subscription to update`),
  plan_payments: z
    .number()
    .int()
    .optional()
    .describe(
      `The number of payments before the recurring plan is complete. 0 for infinite.`
    ),
  plan_amount: z
    .number()
    .optional()
    .describe(`The amount to charge for each payment (x.xx format)`),
  day_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in days, to charge the customer. Cannot be set with 'month_frequency' or 'day_of_month'`
    ),
  month_frequency: z
    .number()
    .int()
    .optional()
    .describe(
      `The frequency, in months, to charge the customer. Cannot be set with 'day_frequency', must be set with 'day_of_month'`
    ),
  day_of_month: z
    .number()
    .int()
    .optional()
    .describe(
      `The day of the month to charge the customer. Cannot be set with 'day_frequency' or 'month_frequency'`
    ),
  start_date: z
    .string()
    .optional()
    .describe(`The date to start the subscription. Format: YYYYMMDD`),
  payment_token: z
    .string()
    .optional()
    .describe(
      `The payment token of the customer's card or check information. This will e generated by Collect.js and usable only once.`
    ),
  googlepay_payment_data: z
    .string()
    .optional()
    .describe(
      `The encrypted token creted when integrated directly with the Google Pay SDK`
    ),
  ccnumber: z
    .string()
    .optional()
    .describe(`The credit card number of the customer`),
  ccexp: z
    .string()
    .optional()
    .describe(`The expiration date of the credit card. Format: MMYY`),
  checkname: z
    .string()
    .optional()
    .describe(`The name on the customer's ACH account`),
  checkaccount: z
    .string()
    .optional()
    .describe(`The account number of the customer's ACH account`),
  checkaba: z
    .string()
    .optional()
    .describe(`The ABA routing number of the customer's ACH account`),
  account_type: z
    .literal("checking")
    .or(z.literal("savings"))
    .optional()
    .describe(`The type of account for the customer's ACH account`),
  account_holder_type: z
    .literal("personal")
    .or(z.literal("business"))
    .optional()
    .describe(`The type of account holder for the customer's ACH account`),
  sec_code: z
    .literal("PPD")
    .or(z.literal("WEB"))
    .or(z.literal("TEL"))
    .or(z.literal("CCD"))
    .optional()
    .describe(`The SEC code for the customer's ACH account`),
  first_name: z.string().optional().describe(`The first name of the customer`),
  last_name: z.string().optional().describe(`The last name of the customer`),
  address1: z.string().optional().describe(`The address of the customer`),
  address2: z.string().optional().describe(`The address of the customer`),
  city: z.string().optional().describe(`The city of the customer`),
  state: z.string().optional().describe(`The state of the customer`),
  zip: z.string().optional().describe(`The zip code of the customer`),
  country: z.string().optional().describe(`The country of the customer`),
  phone: z.string().optional().describe(`The phone number of the customer`),
  email: z
    .string()
    .email()
    .optional()
    .describe(`The email address of the customer`),
  company: z.string().optional().describe(`The company name of the customer`),
  fax: z.string().optional().describe(`The fax number of the customer`),
  orderid: z.string().optional().describe(`The order ID of the order`),
  order_description: z
    .string()
    .optional()
    .describe(`A description of the order`),
  custom_fields: z
    .record(z.string())
    .optional()
    .describe(`Custom fields to add to the subscription`),
  ponumber: z
    .string()
    .optional()
    .describe(`The purchase order number of the order`),
  processor_id: z
    .string()
    .optional()
    .describe(
      `If using Multiple MIDs, route to this processor (processor_id is obtained under Settings ? Transaction Routing in the Control Panel). If allowing multiple payment types, one processor_id can be selected per payment type by submitting comma-separated values.`
    ),
  customer_receipt: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Send the customer a receipt for the subscription. Defaults to true`
    ),
  source_transaction_id: z
    .string()
    .optional()
    .describe(
      `Specifies a payment gateway transaction id in order to associate payment information with a Subscription record`
    ),
  acu_enabled: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(
      `Enable Automated Collection Updater (ACU) for this subscription. Defaults to false`
    ),
  paused_subscription: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .describe(`Pause the subscription after creation. Defaults to false`),
});

export type UpdateSubscription = z.infer<typeof UpdateSubscriptionSchema>;

export const UpdateSubscriptionRequestSchema =
  UpdateSubscriptionSchema.transform((data) => {
    // Then we need to take the custom fields and turn it into merchant_defined_field_1, merchant_defined_field_2, etc.
    const customFields = data.custom_fields || {};
    const transformedCustomFields = Object.keys(customFields).reduce(
      (acc, key, index) => {
        const newKey = `merchant_defined_field_${index + 1}`;
        return { ...acc, [newKey]: customFields[key] };
      },
      {}
    );
    // Then we return the correct object for parsing for the request
    return { ...data, ...transformedCustomFields };
  });

export type UpdateSubscriptionRequest = z.infer<
  typeof UpdateSubscriptionRequestSchema
>;

export const DeleteSubscriptionRequestSchema = z.object({
  recurring: z
    .literal("delete_subscription")
    .describe(`Delete an existing subscription`),
  subscription_id: z.string().describe(`The ID of the subscription to delete`),
});

export type DeleteSubscriptionRequest = z.infer<
  typeof DeleteSubscriptionRequestSchema
>;
