import { z } from "zod";

export const TRANSACTION_URL = "https://secure.nmi.com/api/transact.php";

export const TransactionTypeSchema = z.enum([
  "sale",
  "auth",
  "credit",
  "validate",
  "offline",
]);

// Should only apply to sale and auth transactions
export const PartialPaymentRequestSchema = z.object({});

export const ProductDataSchema = z.object({
  item_product_code: z.string(),
  item_description: z.string(),
  item_commodity_code: z.string(),
  item_unit_of_measure: z.string(),
  item_unit_cost: z.number(),
  item_quantity: z.number(),
  item_total_amount: z.number(),
  item_tax_amount: z.number(),
  item_tax_rate: z.number(),
  item_discount_amount: z.number(),
  item_tax_type: z.string(),
  item_alternate_tax_id: z.string(),
});

export const TransactionSchema = z.object({
  type: TransactionTypeSchema,
  security_key: z.string()
    .describe(`API Security Key assigned to a merchant account.
    New keys can be generated from the merchant control panel in Settings > Security Keys`),
  payment_token: z.string()
    .describe(`The tokenized version of the customer's card or check information. This
    will be generated by Collect.js and is usable only once.`),
  transaction_session_id: z.string().optional()
    .describe(`A single use session ID used by Kount to link the transaction and Data
    Collector information together. This ID should be generated every time a
    payment form is loaded by the cardholder, and be random/unpredictable
    (do not use sequential IDs). This ID should not be reused within a 30 day
    period. This can be used with Collect.js or the Payment API when using
    the Kount DDC with Gateway.js.`),
  googlepay_payment_data: z.string().optional()
    .describe(`The encrypted token created when integration directly to the Google Pay
    SDK.`),
  ccnumber: z.string().optional().describe(`Credit card number`),
  ccexp: z
    .string()
    .optional()
    .describe(`Credit card expiration date in MMYY format`),
  cvv: z.string().optional().describe(`Credit card CVV`),
  checkname: z
    .string()
    .optional()
    .describe(`Name on the customers ACH account (if applicable)`),
  checkaba: z.string().optional().describe(`Routing number`),
  checkaccount: z.string().optional().describe(`Account number`),
  account_holder_type: z
    .literal("business")
    .or(z.literal("personal"))
    .optional()
    .describe(`The type of account holder`),
  account_type: z
    .literal("checking")
    .or(z.literal("savings"))
    .describe(`The type of account`)
    .optional(),
  sec_code: z
    .literal("PPD")
    .or(z.literal("WEB"))
    .or(z.literal("TEL"))
    .or(z.literal("CCD"))
    .describe(`The Standard Entry Class (SEC) code for the transaction`)
    .optional(),
  amount: z
    .number()
    .describe(
      `The amount of the transaction. For validate, use 0.00 or omit this field.`
    ),
  surcharge: z
    .number()
    .default(0.0)
    .optional()
    .describe(`The surcharge amount`),
  currency: z
    .string()
    .default("USD")
    .optional()
    .describe(`The currency of the transaction`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .or(z.literal("cash"))
    .default("creditcard")
    .describe(`The payment method`),
  processor_id: z.string().optional()
    .describe(`If using Multiple MIDs, route to this processor (processor_id is obtained
      under Settings > Transaction Routing in the Control Panel).`),
  authorization_code: z
    .string()
    .optional()
    .describe(`The authorization code for an offline transaction`),
  dup_seconds: z.number().default(0)
    .describe(`Sets the time in seconds for duplicate transaction checking on supported
    processors. Set to 0 to disable duplicate checking. This value should not
    exceed 7862400.`),
  descriptor: z
    .string()
    .optional()
    .describe(`The descriptor to be used for the transaction`),
  descriptor_phone: z
    .string()
    .optional()
    .describe(`The phone number to be used for the transaction`),
  descriptor_address: z
    .string()
    .optional()
    .describe(`The address to be used for the transaction`),
  descriptor_city: z
    .string()
    .optional()
    .describe(`The city to be used for the transaction`),
  descriptor_state: z
    .string()
    .optional()
    .describe(`The state to be used for the transaction`),
  descriptor_postal: z
    .string()
    .optional()
    .describe(`The postal code to be used for the transaction`),
  descriptor_country: z
    .string()
    .optional()
    .describe(`The country to be used for the transaction`),
  descriptor_mcc: z
    .string()
    .optional()
    .describe(`The MCC to be used for the transaction`),
  descriptor_merchant_id: z
    .string()
    .optional()
    .describe(`The merchant ID to be used for the transaction`),
  descriptor_url: z
    .string()
    .optional()
    .describe(`The URL to be used for the transaction`),
  billing_method: z
    .literal("recurring")
    .or(z.literal("installment"))
    .optional()
    .describe(`The billing method`),
  billing_number: z.number().optional()
    .describe(`Specify installment billing number, on supported processors. For use when
    "billing_method" is set to installment`), // installment only
  billing_total: z.number().optional()
    .describe(`Specify installment billing total on supported processors. For use when
    "billing_method" is set to installment.`), // installment only
  order_template: z.string().optional().describe(`Order template ID`),
  order_description: z.string().optional().describe(`Order description`),
  orderid: z.string().optional().describe(`Order ID`),
  ipaddress: z.string().optional().describe(`IP address of the customer`),
  tax: z.number().optional().default(0.0).describe(`The tax amount`),
  shipping: z.number().optional().default(0.0).describe(`The shipping amount`),
  ponumber: z.string().optional().describe(`The purchase order number`),
  first_name: z.string().optional().describe(`The first name of the customer`),
  last_name: z.string().optional().describe(`The last name of the customer`),
  company: z.string().optional().describe(`The company name of the customer`),
  address1: z.string().optional().describe(`The first line of the address`),
  address2: z.string().optional().describe(`The second line of the address`),
  city: z.string().optional().describe(`The city of the address`),
  state: z.string().optional().describe(`The state of the address`),
  zip: z.string().optional().describe(`The postal code of the address`),
  country: z.string().optional().describe(`The country of the address`),
  phone: z.string().optional().describe(`The phone number of the customer`),
  fax: z.string().optional().describe(`The fax number of the customer`),
  email: z.string().optional().describe(`The email address of the customer`),
  social_security_number: z.string().optional()
    .describe(`Customer's social security number, checked against bad check writers
    database if check verification is enabled.`),
  drivers_license_number: z
    .string()
    .optional()
    .describe(`The drivers license number of the customer`),
  drivers_license_dob: z
    .string()
    .optional()
    .describe(`The drivers license date of birth of the customer`),
  drivers_license_state: z
    .string()
    .optional()
    .describe(`The drivers license state of the customer`),
  shipping_firstname: z
    .string()
    .optional()
    .describe(`The first name of the shipping address`),
  shipping_lastname: z
    .string()
    .optional()
    .describe(`The last name of the shipping address`),
  shipping_company: z
    .string()
    .optional()
    .describe(`The company name of the shipping address`),
  shipping_address1: z
    .string()
    .optional()
    .describe(`The first line of the shipping address`),
  shipping_address2: z
    .string()
    .optional()
    .describe(`The second line of the shipping address`),
  shipping_city: z
    .string()
    .optional()
    .describe(`The city of the shipping address`),
  shipping_state: z
    .string()
    .optional()
    .describe(`The state of the shipping address (CC Format)`),
  shipping_zip: z
    .string()
    .optional()
    .describe(`The postal code of the shipping address`),
  shipping_country: z
    .string()
    .optional()
    .describe(`The country of the shipping address (CC Format)`),
  shipping_email: z
    .string()
    .optional()
    .describe(`The email address of the shipping address`),
  custom_fields: z
    .record(z.string(), z.string().or(z.number()))
    .optional()
    .describe(`Custom fields to be used for the transaction`),
  customer_receipt: z
    .literal(true)
    .or(z.literal(false))
    .default(false)
    .describe(`Whether or not to send a receipt to the customer`),
  signature_image: z
    .string()
    .optional()
    .describe(`Base64 encoded image, for use with auth and sale actions only`), // Base64 encoded image, for use with auth and sale actions only
  cardholder_auth: z
    .literal("verified")
    .or(z.literal("attempted"))
    .optional()
    .describe(`Cardholder authentication`),
  cavv: z
    .string()
    .optional()
    .describe(`Cardholder authentication verification value`), // Cardholder authentication verification value
  xid: z.string().optional().describe(`Transaction ID from 3D Secure`), // Transaction ID from 3D Secure
  three_ds_version: z.string().optional().describe(`3D Secure version`), // 3D Secure version
  directory_server_id: z
    .string()
    .optional()
    .describe(`Directory Server ID from 3D Secure`), // Directory Server ID from 3D Secure
  source_transaction_id: z
    .string()
    .optional()
    .describe(
      `Specifies a payment gateway transaction id in order to associate payment information with a Subscription or Customer Vault record`
    ), // Specifies a payment gateway transaction id in order to associate payment information with a Subscription or Customer Vault record
  pinless_debit_override: z
    .literal("Y")
    .or(z.literal("N"))
    .optional()
    .describe(
      `Y or N -- set to Y if you want to override the default behavior of the gateway to process a pinless debit card as a credit card`
    ), // Y or N -- set to Y if you want to override the default behavior of the gateway to process a pinless debit card as a credit card
  // RECURRING
  recurring: z
    .literal("add_subscription")
    .optional()
    .describe(`Add a subscription`),
  plan_id: z.string().optional().describe(`Plan ID`),
  plan_payments: z
    .number()
    .default(0)
    .optional()
    .describe(`Number of payments`),
  plan_amount: z
    .number()
    .default(0)
    .optional()
    .describe(`The amount of the plan`),
  day_frequency: z.number().default(0).optional().describe(`The day frequency`),
  month_frequency: z
    .number()
    .default(0)
    .optional()
    .describe(`The month frequency`),
  day_of_month: z
    .number()
    .default(0)
    .optional()
    .describe(`The day of the month`),
  start_date: z
    .string()
    .optional()
    .describe(`The start date of the subscription`), // YYYYMMDD
  // Customer Vault specific fields
  customer_vault: z
    .literal("add_customer")
    .or(z.literal("update_customer"))
    .optional()
    .describe(`Add or update a customer in the customer vault`),
  customer_vault_id: z.string().optional().describe(`The customer vault ID`),
  // Stored Credentials (CIT/MIT)
  initiated_by: z
    .literal("customer")
    .or(z.literal("merchant"))
    .optional()
    .describe(`The party that initiated the transaction`),
  initial_transaction_id: z
    .string()
    .optional()
    .describe(`The transaction ID of the initial transaction`),
  stored_credential_indicator: z
    .literal("stored")
    .or(z.literal("used"))
    .optional()
    .describe(
      `Use 'stored' when processing the initial transaction, and 'used' when processing subsequent transactions where they already in the vault`
    ), // Use 'stored' when processing the initial transaction, and 'used' when processing subsequent transactions where they already in the vault
  // Level 3 Specific Fields
  shipping_postal: z.string().optional()
    .describe(`Postal/ZIP code of the address where purchased goods will be delivered.
    This field can be identical to the 'ship_from_postal' if the customer is
    present and takes immediate possession of the goods.`),
  ship_from_postal: z
    .string()
    .optional()
    .describe(`The postal code of the shipping address`),
  summary_commodity_code: z
    .string()
    .optional()
    .describe(`The postal code of the shipping address`),
  duty_amount: z.number().default(0.0).optional()
    .describe(`Amount included in the transaction amount associated with the import of
    purchased goods.`),
  discount_amount: z
    .number()
    .default(0.0)
    .optional()
    .describe(`The discount amount`),
  national_tax_amount: z
    .number()
    .default(0.0)
    .optional()
    .describe(`The national tax amount`),
  alternate_tax_amount: z.number().default(0.0)
    .describe(`Second tax amount included in the transaction amount in countries where
    more than one type of tax can be applied to the purchases.`),
  alternate_tax_id: z.string().optional()
    .describe(`Tax identification number of the merchant that reported the alternate tax
    amount.`),
  vat_tax_amount: z.number().default(0.0)
    .describe(`Contains the amount of any value added taxes which can be associated
    with the purchased item.`),
  vat_tax_rate: z.number().default(0.0)
    .describe(`Contains the tax rate used to calculate the sales tax amount appearing.
    Can contain up to 2 decimal places, e.g. 1% = 1.00.`),
  vat_invoice_reference_number: z
    .string()
    .optional()
    .describe(`Invoice number that is associated with the VAT invoice.`),
  customer_vat_registration: z
    .string()
    .optional()
    .describe(
      `Value added tax registration number supplied by the cardholder.`
    ),
  merchant_vat_registration: z.string().optional()
    .describe(`Government assigned tax identification number of the merchant for whom
    the goods or services were purchased from.`),
  order_date: z
    .string()
    .optional()
    .describe(`Purchase order date, defaults to the date of the transaction.`), // YYMMDD
  products: z
    .array(ProductDataSchema)
    .optional()
    .describe(
      `Array of products to be used for the transaction, will be transformed to the correct format for the request.`
    ),
  // FINALLY, Payment Facilitator Specific Fields
  payment_facilitator_id: z.string().optional(),
  submerchant_id: z.string().optional(),
  submerchant_name: z.string().optional(),
  submerchant_address: z.string().optional(),
  submerchant_city: z.string().optional(),
  submerchant_state: z.string().optional(),
  submerchant_postal: z.string().optional(),
  submerchant_country: z.string().optional(),
  submerchant_phone: z.string().optional(),
  submerchant_email: z.string().optional(),

  // ONLY used for partials, hard to include in better ways

  partial_payment_id: z.string().optional()
    .describe(`Unique identifier returned when making the original transaction. This
        should only be used for secondary transactions.`),
  partial_payments: z.literal("settle_partial").or(z.literal("payment_in_full"))
    .describe(`This variable allows the following two values to be passed to it:
    settle_partial: Settles any amount of tender collected (captured partial
    auth's and approved partial sales) at cut off.
    payment_in_full: Required that any split tendered transaction is collected
    in-full before settlement gets initiated.`),
  // type: z.literal("complete_partial_payment").optional()
  //   .describe(`This variable can be passed the value 'complete_partial_payment' which
  //   will complete a payment_in_full transaction that has not been collected in
  //   full. This allows industries that require payment_in_full but subsequently
  //   decide to still settle the transaction even though it has not been collected in
  //   full.`),
});

export const TransactionRequestSchema = TransactionSchema.transform((data) => {
  // First we need to transform the products array to the same keys but _1, _2, _3, etc.
  const products = data.products || [];
  const transformedProducts = products.reduce((acc, product, index) => {
    const productKeys = Object.keys(product);
    const newProduct = productKeys.reduce((productAcc, key) => {
      const newKey = `${key}_${index + 1}`;
      return {
        ...productAcc,
        [newKey]: product[key as keyof typeof product],
      };
    }, {});
    return { ...acc, ...newProduct };
  }, {});
  // Then we need to take the custom fields and turn it into merchant_defined_field_1, merchant_defined_field_2, etc.
  const customFields = data.custom_fields || {};
  const transformedCustomFields = Object.keys(customFields).reduce(
    (acc, key, index) => {
      const newKey = `merchant_defined_field_${index + 1}`;
      return { ...acc, [newKey]: customFields[key] };
    },
    {}
  );
  // Then we return the correct object for parsing for the request
  return { ...data, ...transformedProducts, ...transformedCustomFields };
});

export const CaptureTransactionRequestSchema = z.object({
  type: z.literal("capture"),
  security_key: z.string()
    .describe(`API Security Key assigned to a merchant account.
    New keys can be generated from the merchant control panel in Settings > Security Keys`),
  transaction_id: z.string().describe(`The transaction ID to be captured`),
  amount: z.number().describe(`The amount to be captured`),
  tracking_number: z.string().optional().describe(`The tracking number`),
  shipping_carrier: z.string().optional().describe(`The shipping carrier`),
  orderid: z.string().optional().describe(`Order ID`),
  signature_image: z.string().optional().describe(`Base64 encoded image`),
});

export const VoidTransactionRequestSchema = z.object({
  type: z.literal("void"),
  security_key: z.string()
    .describe(`API Security Key assigned to a merchant account.
    New keys can be generated from the merchant control panel in Settings > Security Keys`),
  transaction_id: z.string().describe(`The transaction ID to be voided`),
  void_reason: z.string().optional().describe(`The reason for the void`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .optional()
    .describe(`The payment method`),
});

export const RefundTransactionSchema = z.object({
  type: z.literal("refund"),
  security_key: z.string()
    .describe(`API Security Key assigned to a merchant account.
    New keys can be generated from the merchant control panel in Settings > Security Keys`),
  transaction_id: z.string().describe(`The transaction ID to be refunded`),
  amount: z.number().optional().describe(`The amount to be refunded`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .optional()
    .describe(`The payment method`),
});

export const UpdateTransactionSchema = z.object({
  type: z.literal("update"),
  security_key: z.string()
    .describe(`API Security Key assigned to a merchant account.
    New keys can be generated from the merchant control panel in Settings > Security Keys`),
  transaction_id: z.string().describe(`The transaction ID to be updated`),
  payment: z
    .literal("creditcard")
    .or(z.literal("check"))
    .optional()
    .describe(`The payment method`),
  tracking_number: z.string().optional().describe(`The tracking number`),
  shipping: z.number().optional().describe(`The shipping amount`),
  shipping_postal: z.string().optional()
    .describe(`Postal/ZIP code of the address where purchased goods will be delivered.
  This field can be identical to the 'ship_from_postal' if the customer is
  present and takes immediate possession of the goods.`),
  ship_from_postal: z
    .string()
    .optional()
    .describe(`The postal code of the shipping address`),
  shipping_country: z
    .string()
    .optional()
    .describe(`The country of the shipping address (CC Format)`),
  shipping_carrier: z
    .literal("ups")
    .or(z.literal("fedex"))
    .or(z.literal("dhl"))
    .or(z.literal("usps"))
    .optional()
    .describe(`The shipping carrier`),
  shipping_date: z.string().optional().describe(`The shipping date YYYYMMDD`),
  order_description: z.string().optional().describe(`Order description`),
  order_date: z
    .string()
    .optional()
    .describe(
      `Purchase order date, defaults to the date of the transaction. YYYYMMDD`
    ), // YYYYMMDD
  customer_receipt: z
    .literal(true)
    .or(z.literal(false))
    .optional()
    .default(false)
    .describe(`Whether or not to send a receipt to the customer`),
  signature_image: z.string().optional().describe(`Base64 encoded image`),
  ponumber: z.string().optional().describe(`The purchase order number`),
  summary_commodity_code: z
    .string()
    .optional()
    .describe(
      `4 character international description code of the overall goods or services being supplied.`
    ),
  duty_amount: z
    .number()
    .optional()
    .describe(
      `Amount included in the transaction amount associated with the import of purchased goods.`
    ),
  discount_amount: z.number().optional().describe(`The discount amount`),
  tax: z.number().optional().default(0.0).describe(`The tax amount`),
  national_tax_amount: z
    .number()
    .optional()
    .describe(`The national tax amount`),
  alternate_tax_amount: z
    .number()
    .optional()
    .describe(
      `Second tax amount included in the transaction amount in countries where more than one type of tax can be applied to the purchases.`
    ),
  alternate_tax_id: z
    .string()
    .optional()
    .describe(
      `Tax identification number of the merchant that reported the alternate tax amount.`
    ),
  vat_tax_amount: z
    .number()
    .optional()
    .describe(
      `Contains the amount of any value added taxes which can be associated with the purchased item.`
    ),
  vat_tax_rate: z
    .number()
    .optional()
    .describe(
      `Contains the tax rate used to calculate the sales tax amount appearing. Can contain up to 2 decimal places, e.g. 1% = 1.00.`
    ),
  vat_invoice_reference_number: z
    .string()
    .optional()
    .describe(`Invoice number that is associated with the VAT invoice.`),
  customer_vat_registration: z
    .string()
    .optional()
    .describe(
      `Value added tax registration number supplied by the cardholder.`
    ),
  merchant_vat_registration: z
    .string()
    .optional()
    .describe(
      `Government assigned tax identification number of the merchant for whom the goods or services were purchased from.`
    ),
  custom_fields: z
    .record(z.string(), z.string().or(z.number()))
    .optional()
    .describe(`Custom fields to be used for the transaction`),
});

export const UpdateTransactionRequestSchema = UpdateTransactionSchema.transform(
  (data) => {
    // Then we need to take the custom fields and turn it into merchant_defined_field_1, merchant_defined_field_2, etc.
    const customFields = data.custom_fields || {};
    const transformedCustomFields = Object.keys(customFields).reduce(
      (acc, key, index) => {
        const newKey = `merchant_defined_field_${index + 1}`;
        return { ...acc, [newKey]: customFields[key] };
      },
      {}
    );
    // Then we return the correct object for parsing for the request
    return { ...data, ...transformedCustomFields };
  }
);

export const TransactionResponseSchema = z.object({
  response: z
    .literal("1")
    .or(z.literal("2"))
    .or(z.literal("3"))
    .describe(
      `1 = Transaction Approved, 2 = Transaction Declined, 3 = Error in Transaction data or system error`
    ),
  responsetext: z.string().describe(`Response message`),
  authcode: z.string().optional().describe(`Authorization code`),
  transactionid: z.string().optional().describe(`Transaction ID`),
  avsresponse: z.string().optional().describe(`AVS response code`),
  cvvresponse: z.string().optional().describe(`CVV response code`),
  orderid: z.string().optional().describe(`Order ID`),
  response_code: z.string().optional().describe(`Response code`),
  emv_auth_response_data: z.string().optional()
    .describe(`This will optionally come back when any chip card data is provided on the
  authorization. This data needs to be sent back to the SDK after an
  authorization.`),
  customer_vault_id: z.string().optional()
    .describe(`The original customer_vault_id passed in the transaction request or the
  resulting customer_vault_id created on an approved transaction.
  Note: Only returned when the "Customer Vault" service is active.`),
  kount_score: z.string().optional()
    .describe(`The Kount "Omniscore" indicating the level of risk on a given transaction.
    The higher the score, the lower the risk.
    Note: Only returned when the "Kount" service is active.`),
  merchant_advice_code: z.string().optional()
    .describe(`Mastercard’s Merchant Advice Code (MAC) is returned in response if one
  is provided by the processor.
  Note: Only returned if API configuration is set to return this value.`),
});
